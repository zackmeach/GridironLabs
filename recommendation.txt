GridironLabs UI Refactor Recommendations (OOTP-style Panels)
===========================================================

Purpose
-------
Define an “OOTP-style” panel system that stays consistent across many screens by making the panel structure,
sizing, semantics, and persistence explicit (so the UI can’t slowly drift screen-by-screen).

Current implementation note
---------------------------
`PanelChrome` in the codebase is currently a minimal container (panel background + `body_layout` only).
This document describes the target contract the implementation will grow toward.

Non-goals
---------
- Pixel-perfect recreation of OOTP.
- QWidget-per-cell tables for dense data (prefer model/view + delegates).


A) Panel contract (the rules every screen must follow)
------------------------------------------------------
PanelChrome structure (vertical stack):
- header_row_1 (PrimaryHeaderBar)   [optional]
- header_row_2 (SecondaryHeaderBar) [optional]
- header_row_3 (TertiaryHeaderBar / SortBar) [optional]
- body                              [required]
- footer                            [optional]

Each header bar provides two fixed slots:
- left_slot  (QHBoxLayout): title / section label / filter group
- right_slot (QHBoxLayout): menu/dropdown / toggles / paging / actions

Composition rules (keep these opinionated):
- If a panel has a title, it lives in header_row_1.left_slot.
- header_row_1.right_slot is for panel-level actions (view toggle, density toggle, menu, “view full …”, etc.).
- header_row_2 is for filters/search/date range/paging/navigation.
- header_row_3 is for “column semantics” (click-sort field headers) or other highlighted controls.
- Section headers (Lineup/Rotation/Bullpen-style) are ONLY in the body as SectionBar rows.

Visibility rules:
- Show a header bar if it contains any visible content (not “if title exists”).
- When a header row is absent, the next region moves up; padding stays consistent.

Panel variants (set via property `panelVariant`):
- default: title + actions (common)
- table: control surface is filters + sort bar; title optional
- toolbarOnly: no title, only controls
- frameless: embedded subpanels; minimal chrome


B) Sizing + density contract (to prevent drift)
----------------------------------------------
Define TWO density modes and treat them as global UI state:
- compact: the default for high-density OOTP feel
- comfortable: for accessibility / large screens / preference

Recommended starting metrics (adjust once, then keep stable):

Density: compact
- panel_padding: 12px
- bar_padding_x: 8px
- bar_padding_y: 4px
- bar_heights: primary=28px, secondary=24px, tertiary=22px, footer=18px
- section_bar_height: 22px
- table_row_height: 22px
- icon_size: 14–16px
- divider_thickness: 1px
- accent_thickness: 2px

Density: comfortable
- panel_padding: 12px
- bar_padding_x: 10px
- bar_padding_y: 6px
- bar_heights: primary=32px, secondary=28px, tertiary=26px, footer=20px
- section_bar_height: 26px
- table_row_height: 26px
- icon_size: 16px
- divider_thickness: 1px
- accent_thickness: 2px

Alignment rules (non-negotiable):
- Numeric columns right-aligned; text columns left-aligned.
- Column labels and values share the same x positions within a view.
- Baseline alignment in bars: title/filter text sits on a consistent baseline.


C) Semantics: accents, roles, and state (styling must match behavior)
--------------------------------------------------------------------
Accents are meaning-bearing UI state, not decoration.
Gold/orange/green (etc.) should correspond to explicit roles/states so:
- QSS can style chrome consistently
- delegates can paint dense rows/cells consistently
- interactions remain predictable (hover/active/selected)

Widget properties (examples; keep the set small and stable):
- panelRole: primary|secondary|embedded
- barRole: primary|secondary|tertiary|footer
- rowRole: sectionHeader|data|summary
- intent: normal|muted|action|warning|success
- isInteractive: true|false
- isActive: true|false

Model/view roles (examples):
- RowRoleRole: sectionHeader|data|summary
- IntentRole: normal|muted|action|warning|success
- AccentRole: none|gold|orange|green
- SecondaryTextRole, IconRole, AvatarRole, TooltipRole, etc.

Styling guideline:
- Keep stable objectName “anchors” for major components (PanelChrome, PanelBar, SectionBar, DataTableView).
- Use a disciplined set of dynamic properties for variants/states. Avoid “property combinatorics”.


D) Standard primitives (build these once, reuse everywhere)
-----------------------------------------------------------
1) PanelChrome + bars
- PrimaryHeaderBar:
  - title label left
  - QToolButton + QMenu / actions right (OOTP-style dropdown)
- SecondaryHeaderBar:
  - filters/search/date range/pagination/nav controls
- SortBar (tertiary header):
  - highlighted clickable field headers (table-ish screens)
- SectionBar (in-body):
  - gold accent lines + left label + optional right-side “column labels”
  - optionally interactive (e.g., clickable header row / sort affordance)
- FooterBar:
  - context/meta string (e.g., “View: batting … / 13 players”) typically right-aligned

2) Body primitives
- KeyValueGrid (small counts):
  - strict label/value alignment
  - numeric values right-aligned
  - best for “Personal Info”, compact rankings, etc.

- SectionedList / SectionedGrid:
  - repeated pattern: SectionBar + aligned rows underneath
  - use model/view if row count is large or interactions are rich

- DataTableView:
  - QTableView/QTreeView base + proxy sorting/filtering
  - consistent header styling + alignment defaults
  - delegates for icons/ratings/colors/badges/multi-line cells
  - prefer this for any “table-ish” or high-row-count surface

- AvatarDetailList (the tall-row headshot + multiline case):
  - QListView (or 1-col QTableView) + QStyledItemDelegate
  - delegate paint() draws avatar + multiple text lines + right-aligned value(s)
  - delegate sizeHint() provides taller rows
  - cache pixmaps (QPixmapCache or your own) so scrolling stays smooth


E) “Special-case” screenshots become compositions (no bespoke panel types)
--------------------------------------------------------------------------
Case: filters where title normally is + highlighted clickable header + table
- header_row_1: filters (left), view/actions (right)
- header_row_3: SortBar
- body: DataTableView

Case: no title, highlighted section at top
- no header_row_1
- body begins with SectionBar + content beneath

Case: multi-row header + nav + highlighted sort bar + footer meta
- header_row_1: title + toggles + some filters
- header_row_2: filters left, paging/nav right
- header_row_3: SortBar
- body: DataTableView
- footer: context/meta right-aligned


F) Resizing: where the “adjustable grid” feel comes from
--------------------------------------------------------
Resizable table columns:
- QTableView/QTreeView with interactive QHeaderView sizing.

Resizable page regions (rows/cols of panels or major sections):
- nested QSplitter (vertical + horizontal) for user resizing.

Frozen first column:
- consider only if you truly need it; it’s achievable in Qt but adds real complexity (often via synced views).


G) Persistence (make it feel “sticky” like OOTP)
------------------------------------------------
Treat persistence as a first-class feature and make it automatic in primitives.
Qt’s QSettings is the usual mechanism.

Recommended QSettings schema (example conventions):

Global
- ui/density = compact|comfortable

Per page (page_id is a stable string identifier)
- ui/pages/<page_id>/splitters/<splitter_id>/state = QByteArray
- ui/pages/<page_id>/tables/<table_id>/columns/widths = map/list
- ui/pages/<page_id>/tables/<table_id>/columns/order = list
- ui/pages/<page_id>/tables/<table_id>/columns/hidden = list
- ui/pages/<page_id>/tables/<table_id>/sort = (column, order)
- ui/pages/<page_id>/filters/<filter_id> = value
- ui/pages/<page_id>/view = value (e.g., batting/pitching)
- ui/pages/<page_id>/selection/<view_id> = value (optional, only if it helps)

Persistence rules:
- Every persisted primitive gets a stable id (splitter_id/table_id/filter_id).
- Version keys when you change structure (…/v2/…).
- Provide sensible defaults and graceful fallback if settings are missing/corrupt.


H) Key decisions to pick early (these affect everything)
--------------------------------------------------------
- Resizing behavior:
  - only resizable table columns?
  - or also resizable page regions via QSplitter?
  - for maximum OOTP feel: do both, with persistence

- Density:
  - commit to compact/comfortable and apply everywhere

- Layout vs model/view:
  - small counts and static info can be layout-based
  - dense/interactive/high-row-count surfaces should be model/view + delegates


I) Practical migration plan (low risk)
--------------------------------------
1) Lock the sizing/density contract (Section B) and wire global density toggling.
2) Build PanelChrome + bar primitives with an opinionated slot API (left/right, multiple rows, footer).
3) Build DataTableView base (model + proxy + delegates) with persistence hooks.
4) Convert one “hard” screen end-to-end (dense + sortable + sectioned) to prove the system.
5) Migrate remaining panels page-by-page, enforcing:
   - composition rules (Section A)
   - metrics/density (Section B)
   - semantics/roles (Section C)
   - persistence conventions (Section G)


